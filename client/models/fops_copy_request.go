// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FopsCopyRequest fops copy request
//
// swagger:model fops_copy_request
type FopsCopyRequest struct {

	// Defines how name conflicts are resolved, if the 'safe' parameter is set to 'true'. If set to 'copy', a new file is written to the destination folder with a non-conflicting name. If not set, the operation is rolled back and operation returns '409 Conflict'.
	// Required: true
	Conflictsolve *string `json:"conflictsolve"`

	// Specifies what happens if a file of the same name exists at the target path and the 'safe' parameter is not set. Set to 'overwrite' to treat the copied file as completely new. Set to 'modify' to treat the new file as a modification of the old one. If the 'override' parameter is not set, the following algorithm is used: if the existing file has a 'deleted' attribute set to 'true', the file is overwritten; if the old file's 'deleted' attribute is false or not set, the file is modified.
	// Required: true
	Override *string `json:"override"`

	// If 'true', ensures that name conflicts are resolved according to the value of the 'conflictsolve' parameter. Defaults to 'false', in which case the operation will overwrite an existing file/folder of the same name.
	// Required: true
	Safe bool `json:"safe"`

	// Full path of the file/folder for copy/move/rename operations.
	// Required: true
	Src *string `json:"src"`

	// Full path of the target file/folder for copy/move/rename operations. In case of files the full/changed name should be included in the target.
	// Required: true
	Target *string `json:"target"`
}

// Validate validates this fops copy request
func (m *FopsCopyRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConflictsolve(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSafe(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSrc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FopsCopyRequest) validateConflictsolve(formats strfmt.Registry) error {

	if err := validate.Required("conflictsolve", "body", m.Conflictsolve); err != nil {
		return err
	}

	return nil
}

func (m *FopsCopyRequest) validateOverride(formats strfmt.Registry) error {

	if err := validate.Required("override", "body", m.Override); err != nil {
		return err
	}

	return nil
}

func (m *FopsCopyRequest) validateSafe(formats strfmt.Registry) error {

	if err := validate.Required("safe", "body", bool(m.Safe)); err != nil {
		return err
	}

	return nil
}

func (m *FopsCopyRequest) validateSrc(formats strfmt.Registry) error {

	if err := validate.Required("src", "body", m.Src); err != nil {
		return err
	}

	return nil
}

func (m *FopsCopyRequest) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("target", "body", m.Target); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this fops copy request based on context it is used
func (m *FopsCopyRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FopsCopyRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FopsCopyRequest) UnmarshalBinary(b []byte) error {
	var res FopsCopyRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
